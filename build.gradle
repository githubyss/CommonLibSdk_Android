// 根据配置是否为 launchApp 决定业务组件 module 是作为 library 还是独立 application
boolean isShellApp = project.getName() == shellApp
boolean isLaunchApp = project.getName() == launchApp
if (isLaunchApp) { // 壳 APP 始终以 application 模式运行，其他业务组件以依赖库模式根据配置拔插
    apply plugin: 'com.android.application'
} else {
    apply plugin: 'com.android.library'
}
apply plugin: 'kotlin-android'
// apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-parcelize'
apply plugin: 'kotlin-kapt'
apply plugin: 'com.alibaba.arouter'

//
android {
    /**
     * SDK 编译版本。
     * 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。
     * 修改 compileSdkVersion 不会改变运行时的行为。当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。
     * 强烈推荐总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API，并且为使用新的 API 做好准备。
     *
     * 就是运行我们这个项目的需要的 SDK。比如如果我们需要在 Android 10.0 Q (API 29) 的版本运行，只要改为 29 就好了。
     */
    compileSdkVersion compile_sdk_version.toInteger()

    /**
     * 构建工具的版本。
     * 其中包括了打包工具 aapt、dx 等等。这个工具的目录位于..sdk_path/build-tools/XX.XX.XX。
     */
    buildToolsVersion build_tools_version

    // 资源前缀检查
    resourcePrefix 'comlib_'

    // defaultConfig，构建类型，主要针对开发生命周期的不同阶段进行配置。
    defaultConfig {
        /**
         * 最小支持的 SDK 版本（手机的 Android 系统版本）。
         * 如果 compileSdkVersion 设置为可用的最新 API，那么 minSdkVersion 则是应用可以运行的最低要求。
         * minSdkVersion 是各大 Android 应用商店用来判断用户设备是否可以安装某个应用的标志之一。
         * 在开发时 minSdkVersion 也起到一个重要角色：lint 默认会在项目中运行，它在你使用了低于 minSdkVersion 的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。
         */
        minSdkVersion min_sdk_version

        /**
         * 新特性支持的 SDK 版本。
         * targetSdkVersion 是 Android 提供向前兼容的主要依据。
         * 在应用的 targetSdkVersion 没有更新之前，系统不会应用最新的行为变化。这允许你在适应新的行为变化之前就可以使用新的 API（因为你已经更新了 compileSdkVersion 不是吗？）
         * targetSdkVersion 指定的值表示你在该目标版本上已经做过了充分的测试，系统将会为你的应用程序启用一些最新的功能和特征。比如，Android 6.0 (API 23) 系统引用了运行时权限这个功能，如果你将 targetSdkVersion 指定为 23 或者更高，那么系统就会为你的程序启动运行时权限。如果你将 targetSdkVersion 指定为 22，那么就说明你的程序最高只在 Android 5.1 (API 22) 系统上做过充分的测试，Android 6.0 系统中引入的新功能就不会启动了。
         * 说通俗一点：
         * 比如你将 targetSdkVersion 设置为 22，涉及某个（或某几个）权限，你直接在 mainfest 中配置权限即可，然后在 java 代码中进行获取权限后的逻辑处理即可。
         * 但如果你将 targetSdkVersion 设置为 23 或更高，你除了在 mainfest 中配置权限外，还需要在 java 代码中判断用户是否同意权限，如果同意，执行什么业务操作；如果不同意，执行什么业务操作（一般是提示某某权限被拒后，某某功能无法正常使用）。如果你只在 mainfest 中配置了权限，targetSdkVersion 又大于等于 23，Java 代码中不进行运行时权限的代码，你的应用程序就直接报错了。
         */
        targetSdkVersion target_sdk_version

        /**
         * 理想上，在稳定状态下三者的关系应该更像这样：
         * minSdkVersion (lowest possible) <= targetSdkVersion == compileSdkVersion (latest SDK)
         * 用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 targetSdkVersion 和 compileVersion 来获得最好的外观和行为。
         */

        // 根据是否为 launchApp 决定添加 applicationId 和版本号。
        if (isLaunchApp) {
            versionCode 1
            versionName "1.0"
            testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
        }

        consumerProguardFiles 'consumer-rules.pro'

        // 默认的数据配置
        // resValue('string', 'appToken', "token123")
        // resValue 'bool', 'isTrue', "false"
        // resValue "integer", 'number', "4"
    }

    // BuildType，构建类型，主要针对开发生命周期的不同阶段进行配置。
    buildTypes {
        // 调试模式
        debug {
            // 是否可以调试
            debuggable isDebuggable.toBoolean()
            // 是否开启混淆
            minifyEnabled isMinifyEnabled.toBoolean()
            // 混淆文件配置
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'

            // 与构建类型相关的数据配置
            // 可以通过 BuildConfig.IS_FIELD
            buildConfigField 'boolean', 'IS_FIELD', 'true'
            // 可以通过 Resources.getString(R.string.appToken) 获取
            resValue('string', 'appToken', "token123")
            resValue('string', 'appToken', "$token")
        }

        // 发行模式
        release {
            debuggable isDebuggable.toBoolean()
            minifyEnabled isMinifyEnabled.toBoolean()
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'

            buildConfigField 'boolean', 'IS_FIELD', 'true'
            resValue('string', 'appToken', "token123")
            resValue('string', 'appToken', "$token")
        }
    }

    // BuildFlavor，构建特征，主要是用以发布给用户不同的应用版本。需要注意的是，这里的版本并非是版本号，而是功能特性。
    if (isLaunchApp) {
        // 多维度定义
        flavorDimensions 'isFree', 'nation'
        // 多渠道打包配置
        productFlavors {
            // 免费渠道
            free {
                // 维度声明，用来表示此处配置属于某一维度
                // 此处表示「是否免费」维度
                dimension 'isFree'
                // 应用包名
                applicationId 'com.githubyss.mobile.common.lib.free'
                // 免费文案标记
                resValue 'string', 'freeTag', "免费版"
                // 是否免费
                resValue 'bool', 'isFree', "true"
                // 是否显示有效期提示
                resValue 'bool', 'isShowValidityHint', "false"
            }
            // 收费渠道
            paid {
                // 此处表示「是否免费」维度
                dimension 'isFree'
                applicationId 'com.githubyss.mobile.common.lib.paid'
                resValue 'string', 'freeTag', "收费版"
                resValue 'bool', 'isFree', "false"
                resValue 'bool', 'isShowValidityHint', "true"
            }
            china {
                // 此处表示「国家维度」
                dimension 'nation'
            }
            france {
                // 此处表示「国家维度」
                dimension 'nation'
            }
        }
    }

    // 源文件路径设置
    sourceSets {
        // main.java.srcDirs += 'src/main/kotlin'

        // main {
        //     java.srcDirs += 'src/main/kotlin'
        //     test.java.srcDirs += 'src/test/kotlin'
        //     res.srcDirs += [
        //             'src/main/res/common',
        //             'src/main/res/value',
        //     ]
        // }

        // 主代码路径
        main {
            java {
                srcDirs 'src/main/java'
                srcDirs 'src/main/kotlin'
            }
            res {
                srcDirs 'src/main/res'
                srcDirs 'src/main/res/common'
            }
            manifest {
                srcFile 'src/main/AndroidManifest.xml'
            }
            jniLibs {
                srcDirs 'libs'
            }
        }

        if (isLaunchApp) {
            // 独立运行代码路径
            alone {
                java {
                    srcDirs 'src/alone/java'
                    srcDirs 'src/alone/kotlin'
                }
                res {
                    srcDirs 'src/alone/res'
                    srcDirs 'src/alone/res/common'
                }
                manifest {
                    srcFile 'src/alone/AndroidManifest.xml'
                }
                jniLibs {
                    srcDirs 'libs'
                }
            }
        }

        // 测试代码路径
        test {
            java {
                srcDirs 'src/test/java'
                srcDirs 'src/test/kotlin'
            }
        }

        sourceSets.all {
            set -> println "${set.name} 的文件是 ${set.java.srcDirs}"
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    packagingOptions {
        exclude 'META-INF/NOTICE.txt'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/metadata.kotlin_module'
        exclude 'META-INF/metadata.jvm.kotlin_module'
    }

    // viewBinding {
    //     enabled = isViewBindingEnabled.toBoolean()
    // }

    // 是否启用 DataBinding
    dataBinding {
        enabled = isDataBindingEnabled.toBoolean()
    }

    // androidExtensions {
    //     experimental = true
    // }

    // lintOptions {
    //     abortOnError false
    // }
}

// 依赖包
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    /* Kotlin */
    api "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"

    /* Androidx Compatibility */
    api "androidx.appcompat:appcompat:$androidx_appcompat_version"
    api "androidx.core:core-ktx:$androidx_core_ktx_version"
    api "androidx.recyclerview:recyclerview:$androidx_recyclerview_version"
    api "androidx.constraintlayout:constraintlayout:$androidx_constraintlayout_version"
    api "androidx.localbroadcastmanager:localbroadcastmanager:$androidx_localbroadcastmanager_version"
    api "androidx.lifecycle:lifecycle-extensions:$androidx_lifecycle_version"

    /* Material Design Support */
    api "com.google.android.material:material:$material_design_version"

    /* Flexbox */
    api "com.google.android:flexbox:$flexbox_version"

    /* ARouter */
    api "com.alibaba:arouter-api:$arouter_api_version"
    kapt "com.alibaba:arouter-compiler:$arouter_compile_version"

    /* Eventbus */
    api "org.greenrobot:eventbus:$eventbus_version"

    /* RxAndroid */
    // api "io.reactivex:rxandroid:$rxandroid_version"
    api "io.reactivex.rxjava3:rxandroid:$rxandroid3_version"

    /* Joda Time */
    api "joda-time:joda-time:$joda_time_version"

    /* Glide */
    api "com.github.bumptech.glide:glide:$glide_api_version"
    kapt "com.github.bumptech.glide:compiler:$glide_compile_version"

    /* Test */
    testImplementation "junit:junit:$junit_version"
    androidTestImplementation "androidx.test.ext:junit:$androidx_test_junit_version"
    androidTestImplementation "androidx.test.espresso:espresso-core:$androidx_test_espresso_core_version"

    // // 按需加载依赖
    // // 整编时将全部组件添加依赖
    // if (buildAll.toBoolean()) {
    //     for (String name : allComponents.split(",")) {
    //         if (!name.isEmpty()) {
    //             implementation(project(":$name"))
    //         }
    //     }
    // }
    // // 非整编时可以选择组件加入容器 App
    // else {
    //     for (String name : loadComponents.split(",")) {
    //         if (!name.isEmpty()) {
    //             implementation(project(":$name"))
    //         }
    //     }
    // }

    // configurations {
    //     all {
    //         resolutionStrategy.eachDependency { DependencyResolveDetails details ->
    //             def requested = details.requested
    //             if (requested.group == 'androidx.appcompat') {
    //                 if (!requested.name.startsWith('multidex')) {
    //                     details.useVersion '1.2.+'
    //                 }
    //             }
    //         }
    //         exclude module: 'httpclient'
    //     }
    // }
}

kapt {
    arguments {
        arg('moduleName', project.getName())
    }
}
